M开挂合并

> 主要思路：得到输入数组每一个所有可能得到得***理想数组***，对于每一个数字有三种可能**x,2x+1,2x-1**，因为只能奇数和偶数合并成为一个奇数。然后把理想数组从大到小排序，***递归***寻找是否能得到理想数组，往后把没用完得数组也用完，不用担心有数字没有使用得情况。
>
> 注意：需要特殊判断5得情况否则递归的时候会导致即使只有一个1和2也会产生一个5导致错误，可以自己判断一下，但我看了c++的代码有些没有判断也是过了的，应该是在递归的时候就标记了每一个数字用了几次没有多次使用之类的。这个M在gym上py的代码只有我的过了，我是仿照过了的c++写出来的
>
> 注释py代码如下以及cf：https://codeforces.com/gym/105143/status  语言选择PyPy3即可

```python
# from math import ceil
from sys import stdin
def input():
    return stdin.readline().rstrip()


def check(w, cnt):
    # 如果当前序列中有v，则可以得到v
    if cnt.get(w, 0) > 0:
        return True
    # 如果当前序列中没有v，且v为偶数，则得不到v
    if (w & 1) == 0:
        return False
    # 如果这个数字是5，则去找是否能得到2和3，这里就是判断特殊情况
    # 我觉得这个5其实不算特殊情况，因为3不是特殊情况，先交一次
    # 会出错的这里，需要判断
    # 这个应该是没有问题的，好吧先放这里
    if w == 5:
    # #     # 要不就是能找到2和3，要不就是能找到两个2和一个1至少的话
        return (cnt.get(2, 0) > 0 and cnt.get(3, 0) > 0) or (cnt.get(2, 0) > 1 and cnt.get(1, 0) > 0)
    # 如果是奇数，就按下面的去找，但是5不采用以下方法
    # 这个返回的就是去找w/2向下取整和另一个数字是否能找到
    return check(w // 2, cnt) and check(w // 2 + 1, cnt)
# 如果把5的特殊判断去除之后，会导致只有一个1和2也可以合成5，
# 因为原函数左边寻找2能找到，右边寻找3，找不到但是，3可以去寻找2和1，2在cnt中有一个，1也有，会导致
# 2虽然只有1个，但是会错误判断
# cnt={1:1,2:1}
# print(check(5,cnt))
# True # 去除特殊判断后会出错
# 这个是删除操作
def del_num(w, cnt):
    # ，如果cnt字典里面有w那么就直接删除一个就可以了
    if cnt.get(w, 0) > 0:
        cnt[w] -= 1
        return
    # 如果找不到的话就是按前面的找到奇数的方法去删除两个通过合并得到的这个奇数的那两个数字
    del_num(w // 2, cnt)
    del_num(w // 2 + 1, cnt)

if __name__ == "__main__":
    # 先读入n和列表
    n = int(input())
    listtemp = list(map(int,input().split()))
    # 然后我们需要的是一个s列表，ans列表，和cnt字典存储所有的数字出现的次数
    # 删除操作在cnt中进行
    # ans是合并后的开挂列表
    s = []
    ans = []
    cnt = {}
    # 遍历一下
    for i in range(n):
        x = listtemp[i]
        # 这个是记录着cnt，也就是字典
        #
        cnt[x] = cnt.get(x, 0) + 1
        # 到此为止记录了所有的原始的数字出现的次数
        # 对每一个输入的listtemp中把出现次数记录之后，对s进行操作
        # 我们把s这一个位置添加一个数组，其实感觉可以是元组，元组好理解一些相当于在同一个索引的地方添加了三个数值
        # 分别为x,2x+1,2x-1这三个
        # x就是输入的原来的数值，
        # 2x+1就是这个数字所能通过和另一个数字合并得到的最大的数字
        # 2x-1同上
        # 后面两个是可能存在的最大的一个数值
        # 看错了，这个s是不断地直接续上去，不是append操作，
        # 所以s的结果是理想下所能得到的所有可能的数值，然后我们对他进行去重复
        s.extend([x, x * 2 + 1, x * 2 - 1])
    # print(s)
    # 然后需要把s进行一个去重，然后从大到小进行排序，s中每一个值都是一个数组，这个数组如何比较
    # 如果是默认的话输出一下把
    # 4
    # 1
    # 2
    # 3
    # 4
    # [1, 3, 1, 2, 5, 3, 3, 7, 5, 4, 9, 7]
    # [9, 7, 5, 4, 3, 2, 1]
    # 2
    # 9
    # 1
    s = list(set(s))
    s.sort(reverse=True)
    # 这个s的就是理想下最大的一个字典序，实际上基本得不到的，
    # 因为s是每一个输入的三个可能的值都添加到s中了，对他去重之后进行操作
    # print(s)
    # 想知道这个s的数组是做什么的
    # 上面一部分先不看，假设这里都知道了
    # 遍历s中的每一个值，去检查判断x是否在cnt中，如果可以存在的话就在ans中添加，然后删除cnt
    # 然后我们遍历一下s的每一个数值，也就是理想情况下的最大字典序列
    # 众所周知，理想和现实的差距是很大的，
    # 所以我们需要对每一个可能的理想数值进行一个check，
    # 这个函数
    # 在上面有定义了，也有解释清楚
    # 就是说如果能找到这个数值就把他添加到ans列表中，然后在cnt中删除一个或者两个或者多个数值
    # 这个遍历完所有的理想数值之后会导致ans的总和和temp列表的总和不一样嘛？
    # 不会，因为s中是添加了所有的temp的原始的值
    # 所以到最后没有用完的时候遍历剩下的都会进行补全操作
    # 那么这个check中的5是否需要特殊判断呢
    for x in s:
        while check(x, cnt):
            ans.append(x)
            del_num(x, cnt)

    print(len(ans))
    print(*ans)
```



